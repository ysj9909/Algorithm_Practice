# -*- coding: utf-8 -*-
"""Merge_Sort.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qr-yx1QzI9_QlGR2yAfucHTIb8i0lMM-

# Merge Sort Practice

* 각 층에서 2의 제곱수 만큼을 한번에 다루므로 총 층의 개수는 log n 이고, 각 층에서 합병하는 연산의 시간 복잡도는 O(n) 이므로 합병 정렬의 시간 복잡도는 O(nlogn)이다.

* 공간 복잡도는 sorted 배열이 필요하므로 O(n)이다.
"""

array = [37, 10, 22, 30, 35, 13, 25, 24]
len =  8


def merge(array, m, middle, n):
    sorted = [0] * len
    i = m
    j = middle + 1
    k = m

    # 두 배열(정렬된)의 값을 작은 순서대로 삽입 ~ O(n)
    while (i <= middle) and (j <= n):
        if array[i] <= array[j]:
            sorted[k] = array[i]
            i += 1
        else:
            sorted[k] = array[j]
            j += 1
        
        k += 1
    
    # 남은 원소를 뒤에 삽입
    if i > middle:
        for idx in range(j, n + 1):
            sorted[k] = array[idx]
            k += 1
    
    else:
        for idx in range(i, middle + 1):
            sorted[k] = array[idx]
            k += 1
    
    # 정렬된 배열을 입력 배열에 삽입
    for idx in range(m, n + 1):
        array[idx] = sorted[idx]


def mergeSort(array, m, n):
    if m < n:
        middle = (m + n) // 2
        mergeSort(array, m, middle)
        mergeSort(array, middle + 1, n)
        merge(array, m, middle, n)

mergeSort(array, 0, len - 1)
print(array)

